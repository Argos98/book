<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Telegram Bots in .NET</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li><a href="example-bot.html"><strong aria-hidden="true">3.</strong> Example</a></li><li><a href="send-msg/index.html"><strong aria-hidden="true">4.</strong> Sending Messages</a></li><li><ol class="section"><li><a href="send-msg/text-msg.html"><strong aria-hidden="true">4.1.</strong> Text Messages</a></li><li><a href="send-msg/multimedia-msg.html"><strong aria-hidden="true">4.2.</strong> Multimedia Messages</a></li></ol></li><li><a href="files/index.html"><strong aria-hidden="true">5.</strong> Working with Files</a></li><li><ol class="section"><li><a href="files/upload.html"><strong aria-hidden="true">5.1.</strong> Upload</a></li></ol></li><li><a href="Login-Widget.html"><strong aria-hidden="true">6.</strong> Login widget</a></li><li><a href="passport/index.html"><strong aria-hidden="true">7.</strong> Passport</a></li><li><a href="proxy.html"><strong aria-hidden="true">8.</strong> HTTP/SOCKS5 Proxy</a></li><li><a href="Integration-Tests.html"><strong aria-hidden="true">9.</strong> Integration tests</a></li><li><a href="Migration-Guide-to-Version-14.x.html"><strong aria-hidden="true">10.</strong> Migration guide =&gt; v14</a></li><li><a href="FAQ.html"><strong aria-hidden="true">11.</strong> FAQ</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Telegram Bots in .NET</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p><a href="https://github.com/TelegramBots/Telegram.Bot"><strong>Telegram.Bot</strong></a> is the most popular .NET Client for <a href="https://core.telegram.org/bots/api">Telegram Bot API</a>. The Bot API is an HTTP-based interface created
for developers keen on building bots for Telegram.</p>
<p>Check <a href="https://core.telegram.org/bots"><em>Bots: An introduction for developers</em></a> to understand what a Telegram bot is and what it can do.</p>
<p>We, <a href="https://github.com/orgs/TelegramBots/people">Telegram Bots team</a>, mainly focus on developing multiple <a href="https://www.nuget.org/profiles/TelegramBots">NuGet packages</a> for creating chatbots.</p>
<table><thead><tr><th align="center">Packages</th><th align="center">Team</th><th align="center">News Channel</th><th align="center">Group Chat</th></tr></thead><tbody>
<tr><td align="center"> <a href="https://www.nuget.org/profiles/TelegramBots"><img src="docs/intro-nuget-logo.png" alt="Packages" /></a> </td><td align="center"> <a href="https://github.com/orgs/TelegramBots/people"><img src="docs/intro-gh-logo.png" alt="Team" /></a> </td><td align="center"> <a href="https://t.me/tgbots_dotnet"><img src="docs/intro-channel-logo.jpg" alt="News Channel" /></a> </td><td align="center"> <a href="https://t.me/joinchat/B35YY0QbLfd034CFnvCtCA"><img src="docs/intro-chat-logo.jpg" alt="Group Chat" /></a> </td></tr>
<tr><td align="center"> Packages we release on NuGet </td><td align="center"> The team contributing to this work </td><td align="center"> Subscribe to <a href="https://t.me/tgbots_dotnet"><code>@tgbots_dotnet</code></a> channel to get our latest news </td><td align="center"> <a href="https://t.me/joinchat/B35YY0QbLfd034CFnvCtCA">Join our chat</a> to talk about bots and ask questions </td></tr>
</tbody></table>
<a class="header" href="#what-is-this-book-for" id="what-is-this-book-for"><h2>What Is This Book For</h2></a>
<p>All Bot API methods are already documented by Telegram<sup class="footnote-reference"><a href="#1">1</a></sup> but this book covers all you need to create a chatbot in
.NET. There are also many concrete examples written in C#. The guides here can even be useful to bot developers, using
other languages/platforms, as it shows best practices in developing Telegram chatbots with examples.</p>
<a class="header" href="#correctness" id="correctness"><h2>Correctness</h2></a>
<p>This project is fully tested using Unit tests and <a href="Integration-Tests.html">Systems Integration tests</a> before each release. In fact, our test cases
are self-documenting and serve as examples for Bot API methods. Once you learn the basics of Telegram chatbots, you
will be able to easily adapt test methods to your own program and make your bot smarter.</p>
<a class="header" href="#get-started" id="get-started"><h2>Get Started</h2></a>
<p><strong>Begin your bot development journey with the <a href="quickstart.html"><em>Quickstart</em></a> guide.</strong></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://core.telegram.org/bots/api">Telegram Bot API</a></p>
</div>
<a class="header" href="#quickstart" id="quickstart"><h1>Quickstart</h1></a>
<a class="header" href="#bot-father" id="bot-father"><h2>Bot Father</h2></a>
<p>Before you start developing a bot, you need to talk to <a href="https://t.me/botfather"><code>@BotFather</code></a> on Telegram. Register a
bot with him and get an access token.</p>
<p><a href="https://t.me/botfather"><img src="./docs/bot-father.jpg" alt="Bot Father" /></a></p>
<p>Access token is a key used to identify and authorize your bot in API
requests so keep it with yourself as a secret. It looks like this:</p>
<pre><code class="language-text">123456789:AAE5cvFhxQ9C7vFGElcpMTNrYrkl3OBFo45
</code></pre>
<a class="header" href="#hello-world" id="hello-world"><h2>Hello World</h2></a>
<p>Now you have a bot, it's time to bring it to life! Create a new console project for your bot. It could be a .NET Core project or a .NET project targeting versions 4.5+.</p>
<blockquote>
<p>This guide uses .NET Core examples but full .NET framework projects work as well.</p>
</blockquote>
<pre><code class="language-bash">dotnet new console
</code></pre>
<p>Add a reference to <code>Telegram.Bot</code> package.</p>
<pre><code class="language-bash">dotnet add package Telegram.Bot
</code></pre>
<p>Open <code>Program.cs</code> file and use the following content. This code fetches Bot information based on its access token by calling <a href="https://core.telegram.org/bots/api#getme"><code>getMe</code></a> method on the Bot API.</p>
<blockquote>
<p>Replace <code>YOUR_ACCESS_TOKEN_HERE</code> with the access token from Bot Father.</p>
</blockquote>
<pre><code class="language-c#">using System;
using Telegram.Bot;

namespace Awesome {
  class Program {
    static void Main() {
      var botClient = new TelegramBotClient(&quot;YOUR_ACCESS_TOKEN_HERE&quot;);
      var me = botClient.GetMeAsync().Result;
      Console.WriteLine(
        $&quot;Hello, World! I am user {me.Id} and my name is {me.FirstName}.&quot;
      );
    }
  }
}
</code></pre>
<p>Running the program gives you the following output:</p>
<pre><code class="language-bash">dotnet run
</code></pre>
<pre><code class="language-text">Hello, World! I am user 123456789 and my name is Awesome Bot.
</code></pre>
<p>Great! This bot is self-aware. To make the bot interact with user, head to the next page.</p>
<a class="header" href="#example" id="example"><h1>Example</h1></a>
<p>On the previous page, we got an access token and used the <a href="https://core.telegram.org/bots/api#getme"><code>getMe</code></a> method to check our setup.
Now, it is time to make an <em>interactive</em> bot that gets users' messages and replies to them like in this screenshot:</p>
<p><img src="docs/shot-example_bot.jpg" alt="Example Image" /></p>
<p>Copy the following code to <code>Program.cs</code>.</p>
<blockquote>
<p>Replace <code>YOUR_ACCESS_TOKEN_HERE</code> with the access token from Bot Father.</p>
</blockquote>
<pre><code class="language-c#">using System;
using System.Threading;
using Telegram.Bot;
using Telegram.Bot.Args;

namespace Awesome {
  class Program {
    static ITelegramBotClient botClient;

    static void Main() {
      botClient = new TelegramBotClient(&quot;YOUR_ACCESS_TOKEN_HERE&quot;);

      var me = botClient.GetMeAsync().Result;
      Console.WriteLine(
        $&quot;Hello, World! I am user {me.Id} and my name is {me.FirstName}.&quot;
      );

      botClient.OnMessage += Bot_OnMessage;
      botClient.StartReceiving();
      Thread.Sleep(999000);
    }

    static async void Bot_OnMessage(object sender, MessageEventArgs e) {
      if (e.Message.Text != null)
      {
        await botClient.SendTextMessageAsync(
          chatId: e.Message.Chat,
          text:   &quot;You said:\n&quot; + e.Message.Text
        );
      }
    }
  }
}
</code></pre>
<p>When you run this program via <code>dotnet run</code>, it runs forever (until forcefully stopped) waiting for
text messages. Open the chat with your bot in Telegram and send him a text message -
you should get a reply in no time.</p>
<p>We subscribe to the <code>OnMessage</code> event on bot client to take action on messages that users send to the bot.</p>
<p>By invoking <code>StartReceiving()</code>, bot client starts fetching updates(<a href="https://core.telegram.org/bots/api#getupdates"><code>getUpdates</code></a> method) for the bot
from Telegram Servers. This is an asynchronous operation, so we use <code>Thread.Sleep()</code> to keep the app running for a while.</p>
<p>When a user sends a message, <code>Bot_OnMessage()</code> gets invoked with the message object in the event argument.
We are expecting a text message so we check for <code>Message.Text</code> value.
Finally, we send a text message back to the same chat we got the message from.</p>
<a class="header" href="#sending-messages" id="sending-messages"><h1>Sending Messages</h1></a>
<ul>
<li><a href="text-msg.html">Send Text Messages (text and more)</a></li>
<li><a href="multimedia-msg.html">Send Multimedia Messages (photo, sticker, etc.)</a></li>
</ul>
<p>There are many different types of message that a bot can send. Fortunately, methods for sending such messages have are
similar. Take a look at these examples:</p>
<p><strong>Sending text message</strong>:</p>
<p><img src="../docs/shot-text_msg.jpg" alt="text message screenshot" /></p>
<pre><code class="language-c#">await botClient.SendTextMessageAsync(
  chatId: e.Message.Chat,
  text:   &quot;Hello, World!&quot;
);
</code></pre>
<p><strong>Sending sticker message</strong>:</p>
<p><img src="../docs/shot-sticker.jpg" alt="sticker message screenshot" /></p>
<pre><code class="language-c#">await botClient.SendStickerAsync(
  chatId:  e.Message.Chat,
  sticker: &quot;https://github.com/TelegramBots/book/raw/master/src/docs/sticker-dali.webp&quot;
);
</code></pre>
<p><strong>Sending video message</strong>:</p>
<p><img src="../docs/shot-video.jpg" alt="video message screenshot" /></p>
<pre><code class="language-c#">await botClient.SendVideAsync(
  chatId:  e.Message.Chat,
  video: &quot;https://github.com/TelegramBots/book/raw/master/src/docs/video-bulb.mp4&quot;
);
</code></pre>
<a class="header" href="#text-messages" id="text-messages"><h1>Text Messages</h1></a>
<a class="header" href="#multimedia-message" id="multimedia-message"><h1>Multimedia Message</h1></a>
<a class="header" href="#working-with-files" id="working-with-files"><h1>Working with Files</h1></a>
<p>First, read the <a href="https://core.telegram.org/bots/api#sending-files">documentation on sending files</a>.</p>
<a class="header" href="#uploading-the-actual-file" id="uploading-the-actual-file"><h2>Uploading the actual file</h2></a>
<pre><code class="language-csharp">using (FileStream fs = System.IO.File.OpenRead(&quot;Local file.pdf&quot;))
{
    InputOnlineFile inputOnlineFile = new InputOnlineFile(fs, &quot;Name for the user.pdf&quot;);
    await Bot.SendDocumentAsync(message.Chat, inputOnlineFile);
}
</code></pre>
<a class="header" href="#uploading-by-file-id" id="uploading-by-file-id"><h2>Uploading by file id</h2></a>
<p>This is the method that you will want to use the most, as it is the most efficient.
After sending a file to the user, or receiving a file, you can send the file again using its ID.</p>
<p>This saves you from uploading the entire file.</p>
<pre><code class="language-csharp">InputOnlineFile inputOnlineFile = new InputOnlineFile(&quot;file id&quot;);
await Bot.SendDocumentAsync(message.Chat, inputOnlineFile);
</code></pre>
<a class="header" href="#uploading-by-url" id="uploading-by-url"><h2>Uploading by URL</h2></a>
<pre><code class="language-csharp">InputOnlineFile inputOnlineFile = new InputOnlineFile(&quot;telegram.org/img/t_logo.png&quot;);
await Bot.SendDocumentAsync(message.Chat, inputOnlineFile);
</code></pre>
<a class="header" href="#telegram-login-widget" id="telegram-login-widget"><h1>Telegram Login Widget</h1></a>
<p>Everything related to the <a href="https://core.telegram.org/widgets/login">Telegram Login Widget</a> has been moved to a separate repository:
<a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.LoginWidget"><code>Telegram.Bot.Extensions.LoginWidget</code></a></p>
<a class="header" href="#telegram-passport" id="telegram-passport"><h1>Telegram Passport</h1></a>
<p><a href="https://telegram.org/blog/passport">Telegram Passport</a> is Telegram's system, enabling developers to integrate user verification that requires the use of actual user documents.</p>
<p>Since this is a feature that deals with highly sensitive user data, Telegram made sure to implement it in an overly-complicated fashion.</p>
<p>To get started, read the following manuals (twice):</p>
<ul>
<li><a href="https://core.telegram.org/passport">Passport manual</a></li>
<li><a href="https://core.telegram.org/bots/api#telegram-passport">Passport API docs</a></li>
</ul>
<a class="header" href="#overview" id="overview"><h3>Overview</h3></a>
<p>A description of the entire Passport process, after the initial setup, is as follows:</p>
<blockquote>
<p><strong><code>Service</code></strong> referes to the organization, servers, websites, applications, connected to the bot</p>
<p><strong><code>User</code></strong> referes to a human (or AI), that wants to login/get verified on a website/application belonging to a <code>service</code></p>
<p><strong><code>Client</code></strong> refers to the software running on a user's device (e.g. Telegram Android app)</p>
</blockquote>
<ol>
<li>The service (website or application) creates a <a href="https://core.telegram.org/passport#sdk">passport request</a>
<ul>
<li>This request contains bot's ID, public key, <a href="https://core.telegram.org/passport#request-parameters">unique payload</a> and selected <a href="https://core.telegram.org/passport#fields">scopes</a></li>
<li>A request also contains a callback (url, Android intent) - see <a href="https://core.telegram.org/passport#sdk">SDK</a></li>
</ul>
</li>
<li>A user clicks on the <code>Log in With Telegram</code> button, which opens their Telegram client
<ul>
<li>At this point, the client verifies that the public key in the request is connected to the bot</li>
</ul>
</li>
<li>The client will prompt the user to enter their cloud password
<ul>
<li>The client fetches encrypted passport data from the server and decrypts it with this password.
This lets the client pre-fill the required fields, if the user has already used Telegram Passport in the past</li>
<li>You should use a good password here, since it is the only thing protecting your documents in case of a data-breach on Telegram's side</li>
</ul>
</li>
<li>The user modifies/adds data fields on the passport authorization screen
<ul>
<li>At this point, the user can visit the service's privacy policy site</li>
<li>Data added/modified at this point is synced with Telegram's servers for later use</li>
<li>If a field is a phone number, Telegram sends the user an SMS to verify the number
(the service can therefore trust that the received phone number is valid and belongs to the user)</li>
</ul>
</li>
<li>The user either submits the passport response, or terminates the request
<ul>
<li>If a user <strong>terminates</strong> the request, the callback is invoked, notifying the service of a failed request.
<em>The process is done here</em></li>
<li>If a user <strong>submits</strong> the response, the process continues in step 6</li>
</ul>
</li>
<li>The client encrypts the response and sends it to Telegram
<ul>
<li>The data is encrypted using AES, using different keys for every field
<ul>
<li>The encrypted data fields are <a href="https://core.telegram.org/bots/api#encryptedpassportelement"><code>EncryptedPassportElement</code></a> objects</li>
</ul>
</li>
<li>The keys from the previous step are encrypted in an extra layer of AES
<ul>
<li>These are the <a href="https://core.telegram.org/passport#datacredentials"><code>DataCredentials</code></a> and <a href="https://core.telegram.org/passport#filecredentials"><code>FileCredentials</code></a> objects</li>
</ul>
</li>
<li>The encrypted keys are then encrypted using the public RSA key in the request
<ul>
<li>This is the <a href="https://core.telegram.org/bots/api#encryptedcredentials"><code>EncryptedCredentials</code></a> object</li>
</ul>
</li>
<li>The client now sends the encrypted data fields and the RSA-encrypted keys to Telegram
<ul>
<li>This is the final <a href="https://core.telegram.org/bots/api#passportdata"><code>PassportData</code></a> object</li>
</ul>
</li>
</ul>
</li>
<li>The client invokes the callback, notifying the service of a successful request</li>
<li>The bot receives a Message Update, with the <a href="https://core.telegram.org/bots/api#passportdata"><code>Message.Passport</code></a> field set
<ul>
<li>The serivce decrypts the passport data</li>
<li>Checks that the payload field matches the payload used in the request</li>
<li>Performs whatever verification of the received data it needs</li>
</ul>
</li>
<li>If the service decides that fields are invalid (e.g. invalid document number)
or that the images are not good enough (e.g. the selfie is blurry, or the driver's licence photo is a troll face),
it notifies Telegram of <a href="https://core.telegram.org/passport#fixing-errors">Errors</a> via the <a href="https://core.telegram.org/bots/api#setpassportdataerrors"><code>SetPassportDataErrors</code></a> method, specifying which fields should be fixed
<ul>
<li>The user will not be able to submit the response again, until the specified fields are modified</li>
<li>The user will be prompted to fix the response only after he/she/it presses the 'login' button again</li>
</ul>
</li>
</ol>
<blockquote>
<p>Only the user and the service ever see the actual data.</p>
<p>Telegram servers only store and relay encrypted data, but can not decrypt it.</p>
</blockquote>
<a class="header" href="#generating-an-rsa-key-pair" id="generating-an-rsa-key-pair"><h3>Generating an RSA key pair</h3></a>
<p>Before you can start, you have to generate your own RSA key pair.
Using openssl this can be done like so:</p>
<p><code>openssl genrsa 4096 &gt; private.key</code></p>
<p>You should be greeted by a message looking something like this:</p>
<pre><code class="language-text">Generating RSA private key, 4096 bit long modulus
.............................++
...............................................++
e is 65537 (0x10001)
</code></pre>
<blockquote>
<p>Fixing issues with openssl (as well as its installation) is outside the scope of this guide</p>
</blockquote>
<p><strong>Do not share this private key!</strong></p>
<p>Go to <a href="https://t.me/botfather">@BotFather</a> and send him the command <code>/setpublickey</code>
(button support for passports is not available, <em>as of writing this article</em>).</p>
<p>You will be asked to enter the bot's name (e.g. <code>@MyTelegramBot</code>).</p>
<p>Now you need to paste in the public key in PEM format.
Using openssl, extract it from the private key with:</p>
<p><code>openssl rsa -in private.key -pubout</code></p>
<p>The key should look something like this:</p>
<pre><code class="language-text">-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAyISVUY2NjPgIMs+of0tM
U/S7T9wmJZbE0BBjxUq7aaz4eK2sBbdE6uYPT== (a bit longer of course)
-----END PUBLIC KEY-----
</code></pre>
<p>BotFather will want the -BEGIN- and -END- pieces as well</p>
<blockquote>
<p>In case your private key gets lost/exposed, you can repeat these steps to change the key with <a href="https://t.me/botfather">@BotFather</a></p>
</blockquote>
<p>You will have to store the private key safely where you process received data.</p>
<a class="header" href="#what-data-to-request" id="what-data-to-request"><h3>What data to request</h3></a>
<p>You now have to decide what kind of data you need from the user.
Is their phone number enough? Do you need all of their identification documents?</p>
<blockquote>
<p><strong>Do not request data you don't actually need!</strong></p>
</blockquote>
<p>You can view all possible data fields you can request from the user in the <a href="https://core.telegram.org/passport#fields">manual</a>.</p>
<blockquote>
<p>These fields are refered to as <code>scope</code> by the manual</p>
</blockquote>
<p>If you select multiple documents of the same type (e.g. identity card and driver's licence), the user will be able to pick which one to share.
Your bot will receive at most:</p>
<ul>
<li>Personal details, address</li>
<li>Phone number and/or an email address</li>
<li>One type of proof of identity document</li>
<li>One type of proof of address document</li>
</ul>
<a class="header" href="#integration-with-your-application-or-website" id="integration-with-your-application-or-website"><h3>Integration with your application or website</h3></a>
<p>When you decide on the needed data fields, it's time to integrate the authentication with your website/application.</p>
<p>You can use the <a href="https://core.telegram.org/passport#sdk">SDK</a>s listed in the manual.</p>
<a class="header" href="#integration-with-your-bot" id="integration-with-your-bot"><h3>Integration with your bot</h3></a>
<p>One more setting you should set with <a href="https://t.me/botfather">@BotFather</a> is your privacy policy.
Use the command <code>/setprivacypolicy</code> and send a link to the policy.
Users will see this link when faced with your passport request.</p>
<p>Now it's time for the bot part. Whenever a user fills in and submits the authentication form,
your bot gets all the information the user sent in a <a href="https://core.telegram.org/bots/api#message"><code>Message</code></a> object,
with the <a href="https://core.telegram.org/bots/api#passportdata"><code>Message.Passport</code></a> field set.</p>
<a class="header" href="#decrypting-the-received-passport-data" id="decrypting-the-received-passport-data"><h3>Decrypting the received passport data</h3></a>
<a class="header" href="#decrypting-credentials" id="decrypting-credentials"><h4>Decrypting credentials</h4></a>
<p>First, you have to decrypt the <a href="https://core.telegram.org/bots/api#encryptedcredentials"><code>EncryptedCredentials</code></a> included in the <a href="https://core.telegram.org/bots/api#passportdata"><code>Message.Passport</code></a> object.
The library provides an extension method on <a href="https://core.telegram.org/bots/api#encryptedcredentials"><code>EncryptedCredentials</code></a> that tries to decrypt them:</p>
<pre><code class="language-csharp">bool TryDecryptCredentials(this EncryptedCredentials, RSA, out Credentials)
</code></pre>
<p>You have to pass in the private key you generated at the start as an <a href="https://stackoverflow.com/q/243646/6845657">RSA object</a>.</p>
<p>If the decryption was successful, you are granted with decrypted <a href="https://core.telegram.org/passport#credentials"><code>Credentials</code></a>.</p>
<p>Now is the time to check the <code>Credentials.Payload</code> field.
It should <strong>exactly match</strong> the payload you set in the <a href="##integration-with-your-application-or-website">authorization request</a>.</p>
<p>Description of the payload field, taken from <a href="https://core.telegram.org/passport#request-parameters">Telegram's passport manual</a>:</p>
<blockquote>
<p><strong>Important:</strong> For security purposes it should be a cryptographically secure unique identifier of the request. In particular, it should be long enough and it should be generated using a cryptographically secure pseudorandom number generator. You should never accept credentials with the same payload twice.</p>
</blockquote>
<a class="header" href="#decrypting-data-fields" id="decrypting-data-fields"><h4>Decrypting data fields</h4></a>
<p>If the payload matches, you can continue on and decrypt the data included in the <code>PassportData.Data</code> field
(array of <a href="https://core.telegram.org/bots/api#encryptedpassportelement"><code>EncryptedPassportElement</code></a>).</p>
<p>Fields that will be present depend on the data you requested, and the documents the user chose to provide.</p>
<p>The <a href="https://core.telegram.org/passport#fields">manual</a> is your friend here. You can also check out the passport unit tests
(link to be added when the passport branch is merged) for an example of handling these fields.</p>
<p>Decrypting the encrypted passport data elements is done by calling the <code>TryDecrypt</code> extension method
on an <a href="https://core.telegram.org/bots/api#encryptedpassportelement"><code>EncryptedPassportElement</code></a> object, passing in the corresponding <a href="https://core.telegram.org/passport#datacredentials"><code>DataCredentials</code></a> you decrypted before.</p>
<p>These credentials can be found inside of the <a href="https://core.telegram.org/passport#credentials"><code>Credentials</code></a> object. (Again, check the unit tests for an example)</p>
<a class="header" href="#decrypting-passport-files" id="decrypting-passport-files"><h4>Decrypting passport files</h4></a>
<p>For getting the document images, you need to go a step further.
Some elements contain the <code>FrontSide</code>, <code>ReverseSide</code> and <code>Files</code> fields.
These contain information on how to download and decrypt said files.
Downloading these files is done like with every other file. See <a href="../files/download.html">downloading files</a>.
Note that these files are encrypted!</p>
<p>To decrypt them call the <code>PassportCryptography.TryDecryptFile</code> method,
passing in the encrypted file bytes and the corresponding <a href="https://core.telegram.org/passport#filecredentials"><code>FileCredentials</code></a>.</p>
<p>The decrypted bytes are a valid jpg file.</p>
<a class="header" href="#working-behind-a-proxy" id="working-behind-a-proxy"><h1>Working Behind a Proxy</h1></a>
<p><code>TelegramBotClient</code> allows you to use a proxy for Bot API connections. This guide covers using three different proxy solutions.</p>
<ul>
<li><a href="#http-proxy">HTTP Proxy</a></li>
<li><a href="#socks5-proxy">SOCKS5 Proxy</a></li>
<li><a href="#socks5-proxy-over-tor">SOCKS5 Proxy over Tor (Testing Only)</a></li>
</ul>
<p><img src="./docs/tg-network.gif" alt="Telegram Network" /></p>
<blockquote>
<p>If you are in a country, such as Iran, where HTTP and SOCKS proxy connections to Telegram servers are blocked, consider using a VPN, using Tor Network, or hosting your bot in other jurisdictions.</p>
</blockquote>
<a class="header" href="#http-proxy" id="http-proxy"><h2>HTTP Proxy</h2></a>
<p>You can pass an <code>IWebProxy</code> to bot client for HTTP Proxies.</p>
<pre><code class="language-csharp">// using System.Net;

var httpProxy = new WebProxy(address: &quot;https://example.org&quot;, port: 8080) {
  // Credentials if needed:
  Credentials = new NetworkCredential(&quot;USERNMAE&quot;, &quot;PASSWORD&quot;)
};
var botClient = new TelegramBotClient(&quot;YOUR_API_TOKEN&quot;, httpProxy);
</code></pre>
<a class="header" href="#socks5-proxy" id="socks5-proxy"><h2>SOCKS5 Proxy</h2></a>
<p>Unfortunately, there is no built-in support for socks proxies in the .NET Standard libraries.
You can use an external NuGet package: <a href="https://www.nuget.org/packages/HttpToSocks5Proxy/"><code>HttpToSocks5Proxy</code></a> provided by one of our team members.</p>
<pre><code class="language-csharp">// using MihaZupan;

var proxy = new HttpToSocks5Proxy(Socks5ServerAddress, Socks5ServerPort);

// Or if you need credentials for your proxy server:
var proxy = new HttpToSocks5Proxy(
  Socks5ServerAddress, Socks5ServerPort, &quot;USERNAME&quot;, &quot;PASSWORD&quot;
);

// Allows you to use proxies that are only allowing connections to Telegram
// Needed for some proxies
proxy.ResolveHostnamesLocally = true;

var botClient = new TelegramBotClient(&quot;YOUR_API_TOKEN&quot;, proxy);
</code></pre>
<a class="header" href="#socks5-proxy-over-tor" id="socks5-proxy-over-tor"><h2>SOCKS5 Proxy over Tor</h2></a>
<p><strong>Warning: Use for Testing only!</strong></p>
<blockquote>
<p>Do not use this method in a production environment as it has high network latency and poor bandwidth.</p>
</blockquote>
<p>Using Tor, a developer can avoid network restrictions while debugging and testing the code
before a production release.</p>
<ol>
<li>Install <a href="https://www.torproject.org/">Tor Browser</a></li>
<li>Open the <code>torcc</code> file with a text editor (Found in <code>Tor Browser\Browser\TorBrowser\Data\Tor</code>)</li>
<li>Add the following lines: (configurations are described below)
<pre><code class="language-text">EntryNodes {NL}
ExitNodes {NL}
StrictNodes 1
SocksPort 127.0.0.1:9050
</code></pre>
</li>
<li>Look at the <a href="#socks5-proxy">Socks5 proxy</a> example above.</li>
<li>Start the Tor Browser</li>
</ol>
<p>Usage:</p>
<pre><code class="language-csharp">// using MihaZupan;

var botClient = new TelegramBotClient(
  &quot;YOUR_API_TOKEN&quot;,
  new HttpToSocks5Proxy(&quot;127.0.0.1&quot;, 9050)
);
</code></pre>
<blockquote>
<p>Note that Tor has to be active at all times for the bot to work.</p>
</blockquote>
<a class="header" href="#configurations-in-torcc" id="configurations-in-torcc"><h3>Configurations in <code>torcc</code></h3></a>
<pre><code class="language-text">EntryNodes {NL}
ExitNodes {NL}
StrictNodes 1
</code></pre>
<p>These three lines make sure you use nodes from the Netherlands as much as possible to reduce latency.</p>
<p><code>SocksPort 127.0.0.1:9050</code></p>
<p>This line tells tor to listen on port 9050 for any socks connections.
You can change the port to anything you want (9050 is just the default), only make sure to use the same port in your code.</p>
<a class="header" href="#integration-tests" id="integration-tests"><h1>Integration Tests</h1></a>
<p>Integration tests are meant to test the project with real data from Telegram. They are semi-automated tests and tester(s) need to interact with bot for some cases during the test execution. Tests could be used as a playground for exploring Bot API methods.</p>
<a class="header" href="#sample-test-diagnostics-output" id="sample-test-diagnostics-output"><h2>Sample Test Diagnostics Output</h2></a>
<p>All the test output goes into the supergroup/private chats specified in configurations or interactively during test execution. You can see some samples of test output below.</p>
<p>Admin bots can change chat photo.</p>
<p><img src="docs/testcase-chatphoto.jpg" alt="Test Case: Set Chat Photo" /></p>
<p>Invoices could be paid in private chats.</p>
<p><img src="docs/testcase-payment.jpg" alt="Test Case: Set Chat Photo" /></p>
<a class="header" href="#how-tests-works" id="how-tests-works"><h2>How Tests Works</h2></a>
<p>These integration tests are written just like regular unit tests with xUnit framework so they seem to be unit tests. When you run test(s), bot makes a request to Bot API and you should see results(message or service notification) in the chat with bot.</p>
<p>When you build the solution, you will see them in Test Explorer window. Tests could be run through .NET Core's CLI as well and that's how this project's CI is set up.</p>
<p>A bot, of course, is needed to test Bot API. This document refers to its user name as <em>MyTestBot</em>.</p>
<p><em>Tester</em> refers to user name of person testing the bot. Multiple testers could interact with bot during
test execution. If super group chat has other members that are not listed as testers, bot ignores their
messages during test execution. Testers must have user names assigned and their user names should be set
in test configurations before hand.</p>
<p>All the tests happen in two chats. A Super Group chat and a Private chat with one of the testers.</p>
<p>Test cases that need tester's interaction to continue, have a limit of usually 2 minues to wait for receving an expected update from API.</p>
<p>Tests could be run individually, in collections, or all at once. All the test collection and test cases whithin them are ordered and tests will not run in parallel.</p>
<a class="header" href="#test-environment-setup" id="test-environment-setup"><h2>Test Environment Setup</h2></a>
<p>Create a Super Group and add bot to it. Promote bot to admin and make sure it has all the permissions. This group needs to have another regular(non-admin) member to be used in tests for chat administration methods(such as Kick, Restrict, Unban). A super group with 2 testers in it, one admin and the other non-admin member, is enough.</p>
<p>Bot should have some features enabled, usually through BotFather, in order to pass tests. These features are listed below:</p>
<ul>
<li>Inline Queries</li>
<li>Payment Provider</li>
</ul>
<p>For making testing process more convenient, set the following commands for MyTestBot as well. The purpose for these commands is explained in the sections below.</p>
<pre><code class="language-text">test - Start test execution
  me - Select me for testing admin methods
</code></pre>
<a class="header" href="#test-configurations" id="test-configurations"><h2>Test Configurations</h2></a>
<p>You can see a list of configuration keys in <code>appsettings.json</code> file. Make a copy of this file and store your configurations there. In addition to <code>appsettings.json</code> and <code>appsettings.Development.json</code>, environment variables prefixed by <code>TelegramBot_</code> are also read into program.</p>
<pre><code class="language-bash">cp appsettings.json appsettings.Development.json
</code></pre>
<a class="header" href="#required-settings" id="required-settings"><h3>Required Settings</h3></a>
<p>Only 2 values must be provided before test execution.</p>
<a class="header" href="#api-token" id="api-token"><h4>API Token</h4></a>
<p>This is required for executing any test case.</p>
<pre><code class="language-json">{
    &quot;ApiToken&quot;: &quot;MyTestBot-API-TOKEN&quot;
    /* ... */
}
</code></pre>
<a class="header" href="#allowed-users" id="allowed-users"><h4>Allowed Users</h4></a>
<p>A comma separated list indicating user name(s) of tester(s). Any update coming from users other than the ones listed here are discarded during test execution.</p>
<pre><code class="language-json">{
    /* ... */
    &quot;AllowedUserNames&quot;: &quot;tester1, Tester2, TESTER3&quot;
    /* ... */
}
</code></pre>
<a class="header" href="#optional-settings" id="optional-settings"><h3>Optional Settings</h3></a>
<p>The following settings are not required for two reasons. Either bot can ask for them during test execution or it is not a required setting for all test cases.</p>
<p>Bot will ask testers in supergroup/private chat for the necessary information. It would be faster to set all the optional settings as well because it makes testing process faster and less manual.</p>
<blockquote>
<p>For obtaining values of necessary settings, you can set breakpoints in some test methods and extract values such as chat id or user id.</p>
</blockquote>
<a class="header" href="#supergroup-chat-id" id="supergroup-chat-id"><h4>Supergroup Chat Id</h4></a>
<p>Bot send  messages to this chat in almost all test cases except cases like sending payments that must be to a private chat.</p>
<p>If not set, before starting any test method, bot waits for a tester to send it a <code>/test</code> command in a super group chat (that bot is also a member of).</p>
<pre><code class="language-json">{
    /* ... */
    &quot;SuperGroupChatId&quot;: -1234567890
    /* ... */
}
</code></pre>
<a class="header" href="#payment-settings" id="payment-settings"><h4>Payment Settings</h4></a>
<a class="header" href="#required-payment-provider-token" id="required-payment-provider-token"><h5>[Required] Payment Provider Token</h5></a>
<p>This token is <strong>required</strong> for any test case regarding payments and must be provided before starting tests.</p>
<p>Consult Telegram API documentations and talk to BotFather to get a test token from a payment provider.</p>
<pre><code class="language-json">{
    /* ... */
    &quot;PaymentProviderToken&quot;: &quot;MY-PAYMENT-PROVIDER-TOKEN&quot;
    /* ... */
}
</code></pre>
<a class="header" href="#testerprivatechatid" id="testerprivatechatid"><h5>TesterPrivateChatId</h5></a>
<p>Invoices could only be sent to private chats. If not set, bot will wait for a tester to send it <code>/test</code> command in a private chat.</p>
<pre><code class="language-json">{
    /* ... */
    &quot;TesterPrivateChatId&quot;: 1234567890
    /* ... */
}
</code></pre>
<a class="header" href="#chat-administration" id="chat-administration"><h4>Chat Administration</h4></a>
<p>For this type of tests, bot should be a priviledged admin of that super group. Methods such as kick or unban will be performed on a regular (non-admin) tester in that chat.</p>
<p>If the following 3 settings are not set, bot will ask a tester to send it <code>/me</code> command in a private chat with bot.</p>
<ul>
<li>Regular Member's User Id</li>
<li>Regular Member's User Name</li>
<li>Regular Member's Private Chat Id</li>
</ul>
<pre><code class="language-json">{
    /* ... */
    &quot;RegularMemberUserId&quot;: 1234567890,
    &quot;RegularMemberUserName&quot;: &quot;tester3&quot;,
    &quot;RegularMemberPrivateChatId&quot;: 1234567890
    /* ... */
}
</code></pre>
<a class="header" href="#date-and-time" id="date-and-time"><h2>Date and Time</h2></a>
<p>All <code>DateTime</code> values are now in UTC format. Here are some examples of usage:</p>
<pre><code class="language-csharp">// Use UTC time when making a request
await BotClient.KickChatMemberAsync(
  chatId: -9876,
  userId: 1234,
  untilDate: DateTime.UtcNow.AddDays(2)
);
</code></pre>
<pre><code class="language-csharp">// Convert to local time (not recommended though)
DateTime localTime = update.Message.Date.ToLocalTime();
</code></pre>
<a class="header" href="#keyboard-buttons" id="keyboard-buttons"><h2>Keyboard Buttons</h2></a>
<p>Many keyboard button types are removed from project. It is more convenient to use factory methods on <code>KeyboardButton</code> and <code>InlineKeyboardButton</code> classes.</p>
<p>Here are some examples:</p>
<pre><code class="language-csharp">// Message having an inline keyboard button with URL that redirects to a page
await BotClient.SendTextMessageAsync(
  chatId: -9876,
  text: &quot;Check out the source code&quot;,
  replyMarkup: new InlineKeyboardMarkup(
    InlineKeyboardButton.WithUrl(&quot;Repository&quot;, &quot;https://github.com/TelegramBots/Telegram.Bot&quot;)
  )
);
</code></pre>
<pre><code class="language-csharp">// Message to a private chat having a 2-row reply keyboard
await BotClient.SendTextMessageAsync(
  chatId: 1234,
  text: &quot;Share your contact &amp; location&quot;,
  replyMarkup: new ReplyKeyboardMarkup(
    new [] { KeyboardButton.WithRequestContact(&quot;Share Contact&quot;) },
    new [] { KeyboardButton.WithRequestLocation(&quot;Share Location&quot;) },
  )
);
</code></pre>
<a class="header" href="#getfileasync" id="getfileasync"><h2><code>GetFileAsync()</code></h2></a>
<p>Downloading a file from Telegram Bot API has 2 steps (<a href="https://core.telegram.org/bots/api#getfile">see docs here</a>):</p>
<ol>
<li>Get file info by calling <code>getFile</code></li>
<li>Download file from <code>https://api.telegram.org/file/bot&lt;token&gt;/&lt;file_path&gt;</code></li>
</ol>
<p><code>GetFileAsync()</code> is replaced by 3 methods. Method <code>GetInfoAndDownloadFileAsync()</code> looks very similar to old <code>GetFileAsync()</code>:</p>
<pre><code class="language-csharp">// Gets file info and saves it to &quot;path/to/file.pdf&quot;
using (var fileStream = System.IO.File.OpenWrite(&quot;path/to/file.pdf&quot;))
{
  File fileInfo = await BotClient.GetInfoAndDownloadFileAsync(
    fileId: &quot;BsdfgLg4Khdlsn-bldBD&quot;,
    destination: fileStream
  );
}
</code></pre>
<blockquote>
<p>Note that calling the method <code>GetInfoAndDownloadFileAsync()</code> results in 2 HTTP requests (steps 1 and 2 above) being sent to the Bot API.</p>
</blockquote>
<p>There are two more methods that assist you with downloading files:</p>
<pre><code class="language-csharp">// New version of GetFileAsync() only gets the file info (step 1)
File fileInfo = await BotClient.GetFileAsync(&quot;BsdfgLg4Khdlsn-bldBD&quot;);

// Download file from server (step 2)
using (var fileStream = System.IO.File.OpenWrite(&quot;path/to/file.pdf&quot;)) {
  await BotClient.DownloadFileAsync(
    filePath: fileInfo.FilePath,
    destination: fileStream
  );
}
</code></pre>
<a class="header" href="#getupdatesasync-setwebhookasync" id="getupdatesasync-setwebhookasync"><h2><code>GetUpdatesAsync()</code>, <code>SetWebhookAsync()</code></h2></a>
<p>Value <code>All</code> is removed from enum <code>Telegram.Bot.Types.Enums.UpdateType</code>. In order to get all kind of updates, pass an empty list such as <code>new UpdateType[0]</code> for <code>allowedUpdates</code> argument.</p>
<a class="header" href="#setwebhookasync" id="setwebhookasync"><h2><code>SetWebhookAsync()</code></h2></a>
<p>Parameter <code>url</code> is required. If you intend to remove the webhook, it is recommended to use <code>DeleteWebhookAsync()</code> instead. However, you could achieve the same result by passing <code>string.Empty</code> value to <code>url</code> argument.</p>
<a class="header" href="#answerinlinequeryasync-and-inlinequeryresult" id="answerinlinequeryasync-and-inlinequeryresult"><h2><code>AnswerInlineQueryAsync()</code> and <code>InlineQueryResult</code></h2></a>
<p>Classes <code>InlineQueryResultNew</code> and <code>InlineQueryResultCache</code> are removed. <code>InlineQueryResult</code> has become the only shared base type for all inline query result classes.</p>
<p>Many shared and redundant properties are removed. This might require significant changes to your <code>.cs</code> files if your bot is in <em>inline mode</em>. Fortunately, all input query results now have constructors with only the required properties as their parameters. This is the preferred way to instantiate input query result instances e.g.:</p>
<p>Instead of:</p>
<pre><code class="language-csharp">// bad way. easy to get exceptions
documentResult = new InlineQueryResultDocument
{
  Id = &quot;some-id&quot;,
  Url = &quot;https://example.com/document.pdf&quot;,
  Title = &quot;Some title&quot;,
  MimeType = &quot;application/pdf&quot;
};
</code></pre>
<p>You should use:</p>
<pre><code class="language-csharp">// good way
documentResult = new InlineQueryResultDocument(
  id: &quot;some-id&quot;,
  documentUrl: &quot;https://example.com/document.pdf&quot;,
  title: &quot;Some title&quot;,
  mimeType: &quot;application/pdf&quot;
);
</code></pre>
<a class="header" href="#sendmediagroupasync" id="sendmediagroupasync"><h2><code>SendMediaGroupAsync()</code></h2></a>
<p><code>InputMediaType</code> is renamed to <code>InputMedia</code>.</p>
<blockquote>
<p><em>ToDo</em></p>
</blockquote>
<a class="header" href="#inline-message-overloads" id="inline-message-overloads"><h2>Inline Message Overloads</h2></a>
<p>Many inline message methods have been replaced with their overloads.</p>
<ul>
<li><code>EditInlineMessageTextAsync</code>--&gt; <code>EditMessageTextAsync</code></li>
</ul>
<blockquote>
<p><em>ToDo</em></p>
</blockquote>
<a class="header" href="#filetosend" id="filetosend"><h2><code>FileToSend</code></h2></a>
<p>New classes have replaced <code>FileToSend</code> struct.</p>
<ul>
<li><code>InputFileStream</code>:</li>
<li><code>InputTelegramFile</code>:</li>
<li><code>InputOnlineFile</code>:</li>
</ul>
<p>In many cases, you can use implicit casting to pass parameters.</p>
<pre><code class="language-csharp">Stream stream = System.IO.File.OpenRead(&quot;photo.png&quot;);
message = await BotClient.SendPhotoAsync(&quot;chat id&quot;, stream);

string fileId = &quot;file_id on Telegram servers&quot;;
message = await BotClient.SendPhotoAsync(&quot;chat id&quot;, fileId);
</code></pre>
<blockquote>
<p><em>ToDo</em>. implicit casts</p>
</blockquote>
<a class="header" href="#updatetype-and-messagetype" id="updatetype-and-messagetype"><h2><code>UpdateType</code> and <code>MessageType</code></h2></a>
<p>Values in these two enums are renamed e.g. <code>UpdateType.MessageUpdate</code> is now <code>UpdateType.Message</code>.</p>
<p><code>MessageType.Service</code> is removed. Now each type of message has its own <code>MessageType</code> value e.g. when a chat member leaves a group, corresponding update contains a message type of <code>MessageType.ChatMemberLeft</code> value.</p>
<a class="header" href="#videonote" id="videonote"><h2><code>VideoNote</code></h2></a>
<p>Properties <code>Width</code> and <code>Height</code> are removed. Vide notes are squared and <code>Length</code> property represents both width and height.</p>
<a class="header" href="#constructor-parameters-instead-of-public-setters" id="constructor-parameters-instead-of-public-setters"><h2>Constructor Parameters Instead of Public Setters</h2></a>
<p>Many types now have the required parameters in their constructors. To avoid running into problems or getting exceptions, we recommend providing all required values in the constructor e.g.:</p>
<pre><code class="language-c#">//bad way:
markup = new InlineKeyboardMarkup {
  Keyboard = buttonsArray,
  ResizeKeyboard = true
};

// better:
markup = new InlineKeyboardMarkup(buttonsArray) {
  ResizeKeyboard = true
};
</code></pre>
<a class="header" href="#how-do-i-use-an-httpsocks-proxy" id="how-do-i-use-an-httpsocks-proxy"><h3>How do I use an HTTP/Socks proxy?</h3></a>
<p>Look at the wiki page: <a href="proxy.html">Working Behind a Proxy</a>.</p>
<a class="header" href="#i-got-a-409-error-what-do-i-do" id="i-got-a-409-error-what-do-i-do"><h3>I got a '409' error. What do I do?</h3></a>
<p>You are trying to receive updates multiple times at the same time. Either you are calling GetUpdates from two instances of the bot, or you are calling GetUpdates while a web hook is already set. That is not supported by the API, only receive on one instance.</p>
<a class="header" href="#how-do-i-get-the-user-id-from-a-username" id="how-do-i-get-the-user-id-from-a-username"><h3>How do I get the user id from a username?</h3></a>
<p>There is no way to do that with the API directly.
You could store a list of known usernames, mapped to ids.
This is <em>not</em> recommended, because usernames can be changed.</p>
<a class="header" href="#how-to-i-get-updates-in-channels" id="how-to-i-get-updates-in-channels"><h3>How to I get updates in channels?</h3></a>
<p>If you are using polling, you will have to subscribe to the <code>OnUpdate</code> event.
Check the <code>UpdateType</code> of the <code>Update</code>. If it is <code>UpdateType.ChannelPost</code> then the <code>Update.ChannelPost</code> property will be set.</p>
<a class="header" href="#this-faq-doesnt-have-my-question-on-it-where-can-i-get-my-torch-and-pitchfork" id="this-faq-doesnt-have-my-question-on-it-where-can-i-get-my-torch-and-pitchfork"><h3>This FAQ doesn't have my question on it. Where can I get my torch and pitchfork?</h3></a>
<p>Check the <a href="https://core.telegram.org/bots/faq"><code>Bots FAQ by Telegram</code></a> and if that doesn't pan out, feel free to let us know in the <a href="https://t.me/joinchat/B35YY0QbLfd034CFnvCtCA">public group chat</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
